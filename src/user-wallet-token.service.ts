// src/user-wallet-token.service.ts
// Service for creating tokens with user's wallet (client-side signing)

import { 
    createV1,
    mintV1,
    TokenStandard,
    mplTokenMetadata
} from "@metaplex-foundation/mpl-token-metadata";
import { 
    publicKey as umiPublicKey,
    generateSigner, 
    percentAmount,
    TransactionBuilder,
    Umi,
    createNoopSigner,
    transactionBuilder,
} from "@metaplex-foundation/umi";

import { createUmi } from "@metaplex-foundation/umi-bundle-defaults";
import { PublicKey } from "@solana/web3.js";
import { getConnection } from './solana.service.js'; 
import { toBigInt } from './utils.js';

interface TokenDetails {
    name: string;
    symbol: string;
    uri: string;
    supply: string;
    decimals: string;
}

function initializeUmi(): Umi {
    const connection = getConnection();
    const umi = createUmi(connection.rpcEndpoint); 
    umi.use(mplTokenMetadata()); 
    return umi;
}

/**
 * Creates an unsigned transaction for token creation with metadata
 * @param userPublicKey - The public key of the user's wallet (as base58 string)
 * @param mintPublicKey - The public key of the mint account (pre-generated by client)
 * @param details - Token details (name, symbol, uri, supply, decimals)
 * @returns Object containing the serialized unsigned transaction
 */
export async function createUnsignedTokenTransaction(
    userPublicKey: string,
    mintPublicKey: string,
    details: TokenDetails
): Promise<{ 
    transaction: string, 
    mintAddress: string,
    message: string 
}> {
    const umi = initializeUmi();
    
    try {
        // Validate public keys
        new PublicKey(userPublicKey);
        new PublicKey(mintPublicKey);
        
        const supplyBigInt = toBigInt(details.supply, Number.parseInt(details.decimals, 10));
        const decimalsNumber = Number.parseInt(details.decimals, 10);

        // Convert public keys to UMI format
        const userPubkey = umiPublicKey(userPublicKey);
        const mintPubkey = umiPublicKey(mintPublicKey);
        
        // Create noop signers (will be signed on client)
        const userSigner = createNoopSigner(userPubkey);
        const mintSigner = createNoopSigner(mintPubkey);

        console.log(`üî® Creating unsigned token transaction`);
        console.log(`üìä Token parameters:`, {
            name: details.name,
            symbol: details.symbol,
            uri: details.uri,
            decimals: decimalsNumber,
            supply: supplyBigInt.toString(),
            tokenStandard: 'Fungible',
            userWallet: userPublicKey,
            mintAddress: mintPublicKey
        });

        // Build transaction in two steps: create metadata, then mint tokens
        let builder = transactionBuilder();
        
        // Step 1: Create token with metadata
        builder = builder.add(
            createV1(umi, {
                mint: mintSigner,
                authority: userSigner,
                name: details.name,
                symbol: details.symbol,
                uri: details.uri,
                sellerFeeBasisPoints: percentAmount(0),
                decimals: decimalsNumber,
                tokenStandard: TokenStandard.Fungible,
                isMutable: true,
                updateAuthority: userPubkey,
                payer: userSigner,
            })
        );
        
        // Step 2: Mint initial supply
        builder = builder.add(
            mintV1(umi, {
                mint: mintPubkey,
                authority: userSigner,
                amount: supplyBigInt,
                tokenOwner: userPubkey,
                tokenStandard: TokenStandard.Fungible,
            })
        );

        // Build the transaction (without sending)
        const builtTransaction = await builder.build(umi);
        
        // Serialize the transaction to base64
        const serializedTx = Buffer.from(
            umi.transactions.serialize(builtTransaction)
        ).toString('base64');

        console.log(`‚úÖ Unsigned transaction created successfully`);
        console.log(`üìù Mint address: ${mintPublicKey}`);
        console.log(`üì¶ Transaction serialized (${serializedTx.length} chars)`);

        return {
            transaction: serializedTx,
            mintAddress: mintPublicKey,
            message: "Transaction created successfully. Sign with your wallet and submit."
        };

    } catch (error: any) {
        console.error("‚ùå Error creating unsigned token transaction:", error);
        throw new Error("Failed to create unsigned transaction. Please check your inputs and try again.");
    }
}

/**
 * Submits a signed transaction to the blockchain
 * @param signedTransaction - Base64 encoded signed transaction
 * @returns Transaction signature
 */
export async function submitSignedTransaction(
    signedTransaction: string
): Promise<{ signature: string, message: string }> {
    const umi = initializeUmi();
    
    try {
        // Deserialize the signed transaction
        const txBuffer = Buffer.from(signedTransaction, 'base64');
        const transaction = umi.transactions.deserialize(txBuffer);

        console.log(`üì§ Submitting signed transaction...`);

        // Send the signed transaction
        const signature = await umi.rpc.sendTransaction(transaction);

        console.log(`‚úÖ Transaction submitted successfully`);
        console.log(`üìù Signature: ${signature}`);

        // Wait for confirmation with proper strategy
        const latestBlockhash = await umi.rpc.getLatestBlockhash();
        const confirmResult = await umi.rpc.confirmTransaction(signature, {
            strategy: { 
                type: 'blockhash', 
                blockhash: latestBlockhash.blockhash,
                lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
            },
            commitment: 'confirmed'
        });

        if (confirmResult.value.err) {
            throw new Error(`Transaction failed: ${JSON.stringify(confirmResult.value.err)}`);
        }

        console.log(`‚úÖ Transaction confirmed`);

        return {
            signature: signature.toString(),
            message: "Transaction confirmed successfully"
        };

    } catch (error: any) {
        console.error("‚ùå Error submitting signed transaction:", error);
        throw new Error("Failed to submit transaction. Please ensure the transaction is properly signed.");
    }
}
